#pragma once
#include <fc/filesystem.hpp>
#include <fc/reflect/reflect.hpp>
#include <fc/crypto/elliptic.hpp>
#include <fc/time.hpp>
#include <fc/io/enum_type.hpp>
#include <bts/bitchat/bitchat_private_message.hpp>

namespace bts { namespace bitchat {

  namespace detail { class message_db_impl; }

  enum message_status
  {
      draft,
      received,
      doing_pow,
      waiting_ack
  };

  struct message_header
  {
      message_header():read_mark(false){}

      fc::enum_type<uint32_t,private_message_type>   type;
      fc::time_point_sec                             received_time;
      fc::ecc::public_key_data                       to_key;
      fc::ecc::public_key_data                       from_key;
      fc::uint256                                    digest;
      fc::enum_type<uint8_t,message_status>          status;
      fc::ecc::compact_signature                     from_sig;
      fc::time_point_sec                             from_sig_time;
      fc::time_point_sec                             ack_time;   // the time the ack for this msg was received
      bool                                           read_mark;  // whether or not the user has read the message
  };
  
  /**
   *  Stores and indexes messages that are known to this
   *  client.  Messages are stored in their unencrypted form currently.
   *
   *  @note the message DB is something that will probably
   *  change frequently and we will want to support upgrade
   *  migrations.
   */
  class message_db
  {
     public:
       message_db();
       ~message_db();
       
       /**
        *  @param key - defines the AES key used to encrypt/decrypt the messages stored
        *               in the database.
        *  @throw if the key is invalid or the database is unable to be created.
        */
       void open( const fc::path& dbdir, const fc::uint512& key, bool create = true );
       
       /**
        * Stores a new or modified message into the database and returns a message_header index to the message.
        * For storing a new message, previous_msg_header should be null. To modify an existing message,
        * pass the message_header generated when the previous store_message call was made.
        * Important: All messages should have a unique sig_time! Otherwise, it would be possible for two
        *            message_headers to get the same message digest and point to the same message contents.
        *  //DLNFIX add an assertion or exception to check for this condition soon if code currently doesn't
        *           warn about it.
        * @param msg - message to be stored in database (stored unencrypted)
        * @param previous_msg_header - if modifying a message already stored in this database, you
        *                              must pass the message_header index generated when it was last stored.
        * @return msg_header that acts as index for modifying the message in the database. You must keep
        *         this index around to modify or remove the message in the database.
        */
       message_header store_message(const decrypted_message& msg, const message_header* previous_msg_header);
       /**
        * Remove a message from the database.
        * @param msg_header - Input is the index to the message generated by a previous call to store_message.
        */
       void           remove_message(const message_header& msg_header);
       /**
        * This function acts as quick method to update a field in the message_header only and
        * should only be used with extreme caution.
        * This function is currently only used to quickly mark a message as having been read.
        * If you modify a field in the msg_header that's used for equivalence (read field is not used), 
        * you need to first remove the unmodified form of the msg_header.
        */
       void           store_message_header(const message_header& msg_header);
       /**
        Currently unused. Consider eliminating this function or otherwise restructuring API functions
        fulfilled by store_message_header() for increased safety.
        */
       void           remove_message_header(const message_header& msg_header);


       
       std::vector<message_header>  fetch_headers( private_message_type t, 
                                           fc::time_point_sec from_time = fc::time_point(), 
                                           fc::time_point_sec to_time = fc::time_point::maximum(),
                                           fc::optional<fc::ecc::public_key_data> to_key = fc::optional<fc::ecc::public_key_data>(),
                                           fc::optional<fc::ecc::public_key_data> from_key  = fc::optional<fc::ecc::public_key_data>());
       
       std::vector<char>            fetch_data(  const fc::uint256& digest );
     private:
       std::unique_ptr<detail::message_db_impl> my;
  };

  typedef std::shared_ptr<message_db> message_db_ptr;

} } // bts::bitchat
FC_REFLECT_ENUM( bts::bitchat::message_status, 
      (draft)(received)(doing_pow)(waiting_ack) )

FC_REFLECT( bts::bitchat::message_header, 
    (type)
    (received_time)
    (to_key)
    (digest) 
    (from_key)
    (from_sig)
    (from_sig_time)
    (ack_time)
    (read_mark)
    (status)
    )
